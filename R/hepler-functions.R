# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' @rdname Menu-window-functions
#' @export
#' @keywords internal
gettext_EZR <- function(...) {
    gettext(domain = "R-RcmdrPlugin.EZR", ...)
}

# ------------------------------------------------------------------------------
# Make a unique name for an object (e.g., data frame) by adding numbers
#
# @param name - name of dataset before suffix and preffix are added.
unique_obj_name <- function(name = ActiveDataSet(),
                            preffix = "",
                            suffix = "",
                            list_of_choices = objects(all.names = TRUE, envir = .GlobalEnv),
                            all_numbered = FALSE) {
    initial_name <- glue("{preffix}{name}{suffix}")

    list_to_check <- if (all_numbered) {
        c(list_of_choices, initial_name, initial_name)

    } else {
        c(list_of_choices, initial_name)
    }

    list_to_check %>%
        make.unique(sep = "_") %>%
        rev() %>% .[1]   # select the last element
}
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
unique_df_name <- function(name = ActiveDataSet(),
                           preffix = "",
                           suffix = "",
                           list_of_choices = objects(all.names = TRUE, envir = .GlobalEnv),
                           all_numbered = FALSE) {

    unique_obj_name(name, preffix, suffix, list_of_choices, all_numbered)
}
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
unique_colname <- function(name = "",
                           preffix = "",
                           suffix = "",
                           list_of_choices = listVariables(),
                           all_numbered = FALSE) {

    unique_obj_name(name, preffix, suffix, list_of_choices, all_numbered)
}
unique_colname_2 <- function(name = "",
                             preffix = "",
                             suffix = "",
                             list_of_choices = listVariables(),
                             all_numbered = TRUE) {

    unique_obj_name(name, preffix, suffix, list_of_choices, all_numbered)
}

# ------------------------------------------------------------------------------
# Formatat code in a `tidyverse` style
style_cmd <- function(command, indent_by = 4, ...) {
    cmd <- styler::style_text(command, indent_by = indent_by, ...)
    paste0(as.character(cmd), collapse = "\n")
}
# ------------------------------------------------------------------------------
list_summaries_Models <- function(envir = .GlobalEnv, ...) {
    objects <- ls(envir = envir, ...)
    if (length(objects) == 0)
        NULL
    else objects[sapply(objects,
                        function(.x) "summaries_model" == (class(get(.x, envir = envir))[1]))]
}

# ------------------------------------------------------------------------------
#' @rdname Menu-window-functions
#' @export
#' @keywords internal
function_not_implemented <- function(x = NULL) {

    doItAndPrint("# ~~~ Not implemented yet! ~~~\n")

    if (is.null(x)) {
        x <- "This function"
    }

    text <- glue("# ~~~ {x} will be implemented  \n ",
                 "# ~~~ in the future versions of package `RcmdrPlugin.biostat`! ")

    msg <- glue("{x} will be implemented in the future versions of package",
                " `RcmdrPlugin.biostat`! ")

    doItAndPrint(text)
    Message(msg, type = "warning")
}
# ------------------------------------------------------------------------------
spaces <- function(n) {
    paste0(rep(" ", length = n), collapse = "")
}
# ------------------------------------------------------------------------------
nonFactorsP <- function(n = 1) {
    #  n - number of non-factors.
    activeDataSetP() && length(setdiff(listVariables(), listFactors())) >= n
}
# ------------------------------------------------------------------------------
#' @rdname Menu-window-functions
#' @export
#' @keywords internal
class_ggplot_P <- function(n = 1) {
    #  n - number of non-factors.
    length(objects_of_class("ggplot", envir = .GlobalEnv)) >= n
}

# ------------------------------------------------------------------------------
#' @rdname Menu-window-functions
#' @export
#' @keywords internal
objects_in_env_P <- function(n = 1, envir = .GlobalEnv, ...) {
    #  n - number of non-factors.
    isTRUE(length(objects(envir = envir, ...)) >= n)
}
# ------------------------------------------------------------------------------
glue <- glue::glue
# ------------------------------------------------------------------------------
eval_glue <- function(..., envir = parent.frame(),
                      .sep = "", .open = "{", .close = "}") {

    x2 <- glue::glue(..., .envir = envir, .open = .open, .close = .close)
    eval(parse(text = x2), envir = envir)
}
# ------------------------------------------------------------------------------
eval_ <- function(x, envir = parent.frame(), ...) {
    eval(parse(text = x), envir = envir, ...)
}
# ------------------------------------------------------------------------------
gettext_Bio <- function(...) {
    gettext(..., domain = "R-RcmdrPlugin.biostat")
}
# ------------------------------------------------------------------------------
#' Does active dataset contain characters?
#'
#' Return TRUE, if at least n character variables exist in the active dataset.
#'
#' @param n Minimum number of character variables
#'
#' @keywords internal
#' @export
characterP <- function(n = 1) {
    activeDataSetP() &&
        (sum(eval_glue("mapply(is.character, {activeDataSet()})")) >= n)
}
# ------------------------------------------------------------------------------
#' Does active dataset contain logicals?
#'
#' Return TRUE, if at least n locical variables exist in the active dataset.
#'
#' @param n Minimum number of logical variables
#'
#' @keywords internal
#' @export
logicalP <- function(n = 1) {
    activeDataSetP() &&
        (sum(eval_glue("mapply(is.logical, {activeDataSet()})")) >= n)
}
#' Character variable names in active dataset
#'
#' @keywords internal
#' @export
variables_chr <- function() {
    objects_of_class("character",
                     envir = as.environment(globalenv()[[activeDataSet()]]))
}
#' Logical variable names in active dataset
#'
#' @keywords internal
#' @export
variables_lgl <- function() {
    objects_of_class("logical",
                     envir = as.environment(globalenv()[[activeDataSet()]]))
}

#' ...
#'
#' @keywords internal
#' @export
var_pos_n <- function(variables,
                      type = c("all",
                               "factor",
                               "numeric",
                               "nonfactor",
                               "twoLevelFactor",
                               "character",
                               "logical"
                               ), vars = NULL)
{
    if (is.null(variables))
        return(NULL)
    type <- match.arg(type)
    if (is.null(vars))
        vars <- switch(
            type,
            all = Variables(),
            character = variables_chr(),
            logical = variables_lgl(),
            factor = Factors(),
            numeric = Numeric(),
            nonfactor = setdiff(Variables(),
                                Factors()), twoLevelFactor = TwoLevelFactors())
    if (any(!variables %in% vars))
        NULL
    else apply(outer(variables, vars, "=="), 1, which) - 1
}


# ------------------------------------------------------------------------------
#' Does dataset contain certain number of variables?
#'
#' Return TRUE, if at least n variables exist in the active dataset.
#'
#' @param n Minimum number of character variables
#'
#' @keywords internal
#' @export
variablesP <- function(n = 1) {
    activeDataSetP() && length(listVariables()) >= n
}
# ------------------------------------------------------------------------------

#
# ------------------------------------------------------------------------------
#' Is the first class "data.frame"
#'
#' Check if the first class of active Rcmdr dataset is "data.frame"
#' @keywords internal
#' @export
first_class_is_dataframeP <- function() {
    activeDataSetP() &&
        (eval_glue("class({activeDataSet()})[1]") == "data.frame")
}
#' [!] Is the first class the same as in brackets?
#'
#' Check if the first class of active Rcmdr dataset is the same as determined.
#' @keywords internal
#' @export
first_class_isP <- function(df_class) {
    activeDataSetP() &&
        (eval_glue("class({activeDataSet()})[1]") == df_class)
}
# ------------------------------------------------------------------------------
#' Chech the class of the active model in Rcmdr
#'
#' @param class_ (string) a character vector of length 1. The name of class.
#'
#' @keywords internal
#' @export
modelClassP <- function(class_) {
    activeModelP() && (inherits(
        x = get(ActiveModel(), envir = .GlobalEnv),
        what = class_))
}
# ------------------------------------------------------------------------------
#' Make path to relative
#'
#' Make absolute path into relative one in respect to current working directory.
#'
#' @param str (character) Sting (or vector of strings) with absolute path.
#'
#' @keywords internal
#' @export
make_relative_path <- function(str) {
    sub(paste0(getwd(), "/?"), "", str)
}

#' Extract file parts.
#' @name extract-fileparts
#' @param str (character) Path to file (with filename and extension).
#'
#' @keywords internal
#' @export
extract_filename <- function(str) {
    sub("(.*\\/)([^.]+)(\\.[[:alnum:]]+$)", "\\2", str)
}
#' @rdname extract-fileparts
#' @keywords internal
#' @export
extract_path <- function(str) {
    sub("(.*\\/)([^.]+)(\\.[[:alnum:]]+$)", "\\1", str)
}
#' @rdname extract-fileparts
#' @keywords internal
#' @export
extract_extension <- function(str) {
    sub("(.*\\/)([^.]+)(\\.[[:alnum:]]+$)", "\\3", str)
}

